require 'uv'

module FileColumn # :nodoc:

  class BaseUploadedFile # :nodoc:

    def transform_with_uv
      if needs_transform_uv?
        content = ""
        File.open(absolute_path, "r+") { |f| content = f.read }

        possible_mode = Uv.syntax_for_file(absolute_path)

        mode = possible_mode.empty? ? 'plain_text' : possible_mode.first.first

        result = Uv.parse(content, "xhtml", mode, true, options[:uv][:theme])
        path = absolute_path << get_file_suffix
        File.open(path, "w+") { |f| f.write(result) }
        GC.start
      end
    end

    def get_file_suffix
      "." << options[:uv][:theme] << ".html"
    end

    private

    def needs_transform_uv?
      path = absolute_path << get_file_suffix
      options.has_key?(:uv) and not File.exists?(path)
    end

  end

  # If you are using file_column to upload images, you can
  # directly process the textual files with Ultraviolet.
  # You can find more information at http://ultraviolet.rubyforge.org/index.xhtml
  #
  # You can control what to do by adding a <tt>:uv</tt> option
  # to your options hash. All operations are performed immediately
  # after a new file is assigned to the file_column attribute (i.e.,
  # when a new file has been uploaded).
  #
  # == Colorize text
  # To colorize the uploaded text according to an UV themes,
  # just use the <tt>:theme</tt> option:
  #
  #    file_column :file, :uv => { :theme => "blackboard" }
  #
  # If the uploaded file cannot be transformed by UV, file_column will
  # to nothing.
  #
  # The files generated by UV are HTML files. They are named by the original filename
  # and the theme name.
  #
  # If you upload a cvs.diff file, and if you use the blackboard theme
  # you will have a cvs.diff.blackboard.html file in the same directory as the cvs.diff file.
  #
  # <b>Note:</b> You'll need the
  # UV extension being installed  in order to use file_column's
  # uv integration.
  module UltraVioletExtension

    def self.file_column(klass, attr, options) # :nodoc:
      require 'uv'
      options[:uv][:theme] = "espresso_libre" unless options[:uv].has_key? :theme

      state_method = "#{attr}_state".to_sym
      after_assign_method = "#{attr}_uv_after_assign".to_sym

      klass.send(:define_method, after_assign_method) do
        if send(state_method).get_content_type =~ /^text\//
          self.send(state_method).transform_with_uv
        end
      end

      options[:after_upload] ||= []
      options[:after_upload] << after_assign_method
    end

  end
end
